# 실습 프로젝트

> Phase 1에서 배운 내용을 실습으로 확인합니다.

## 프로젝트 1: 카운터 앱

### 목표

- useState 기본 사용법
- 함수형 업데이트
- 여러 State 관리

### 요구사항

```jsx
import React, { useState } from "react";
import { View, Text, Button, StyleSheet } from "react-native";

function Counter() {
  const [count, setCount] = useState(0);
  const [step, setStep] = useState(1);

  // TODO: 구현하기
  // 1. +step 버튼: count를 step만큼 증가
  // 2. -step 버튼: count를 step만큼 감소
  // 3. Reset 버튼: count를 0으로 초기화
  // 4. Step 변경 버튼들: step을 1, 5, 10으로 변경

  return (
    <View style={styles.container}>
      <Text style={styles.count}>Count: {count}</Text>
      <Text style={styles.step}>Step: {step}</Text>

      {/* 버튼들 구현 */}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    padding: 20,
  },
  count: {
    fontSize: 48,
    fontWeight: "bold",
    marginBottom: 20,
  },
  step: {
    fontSize: 24,
    marginBottom: 40,
  },
});

export default Counter;
```

### 해답

<details>
<summary>해답 보기</summary>

```jsx
function Counter() {
  const [count, setCount] = useState(0);
  const [step, setStep] = useState(1);

  const increment = () => {
    setCount((prev) => prev + step);
  };

  const decrement = () => {
    setCount((prev) => prev - step);
  };

  const reset = () => {
    setCount(0);
  };

  return (
    <View style={styles.container}>
      <Text style={styles.count}>Count: {count}</Text>
      <Text style={styles.step}>Step: {step}</Text>

      <View style={styles.buttonRow}>
        <Button title={`-${step}`} onPress={decrement} />
        <Button title="Reset" onPress={reset} />
        <Button title={`+${step}`} onPress={increment} />
      </View>

      <Text style={styles.label}>Change Step:</Text>
      <View style={styles.buttonRow}>
        <Button title="1" onPress={() => setStep(1)} />
        <Button title="5" onPress={() => setStep(5)} />
        <Button title="10" onPress={() => setStep(10)} />
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    padding: 20,
  },
  count: {
    fontSize: 48,
    fontWeight: "bold",
    marginBottom: 20,
  },
  step: {
    fontSize: 24,
    marginBottom: 40,
  },
  label: {
    fontSize: 18,
    marginTop: 40,
    marginBottom: 10,
  },
  buttonRow: {
    flexDirection: "row",
    gap: 10,
  },
});
```

</details>

### 학습 포인트

- [ ] 함수형 업데이트를 사용했는가?
- [ ] State가 서로 독립적으로 관리되는가?
- [ ] 버튼을 빠르게 여러 번 클릭해도 정확한가?

---

## 프로젝트 2: Todo 리스트

### 목표

- 리스트 렌더링
- key prop 사용
- 배열 State 업데이트 (불변성)
- 조건부 렌더링

### 요구사항

```jsx
import React, { useState } from "react";
import { View, Text, TextInput, Button, FlatList, StyleSheet } from "react-native";

function TodoList() {
  const [todos, setTodos] = useState([
    { id: 1, text: "Buy milk", completed: false },
    { id: 2, text: "Clean room", completed: false },
  ]);
  const [input, setInput] = useState("");

  // TODO: 구현하기
  // 1. addTodo: 새 todo 추가 (id는 Date.now() 사용)
  // 2. toggleTodo: todo의 completed 토글
  // 3. deleteTodo: todo 삭제
  // 4. 완료된 항목은 취소선 스타일 적용

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Todo List</Text>

      <View style={styles.inputContainer}>
        <TextInput style={styles.input} value={input} onChangeText={setInput} placeholder="Enter todo" />
        <Button title="Add" onPress={addTodo} />
      </View>

      <FlatList
        data={todos}
        keyExtractor={(item) => item.id.toString()}
        renderItem={({ item }) => <TodoItem todo={item} onToggle={toggleTodo} onDelete={deleteTodo} />}
      />
    </View>
  );
}

function TodoItem({ todo, onToggle, onDelete }) {
  return (
    <View style={styles.todoItem}>
      <Text style={[styles.todoText, todo.completed && styles.completed]} onPress={() => onToggle(todo.id)}>
        {todo.text}
      </Text>
      <Button title="Delete" onPress={() => onDelete(todo.id)} color="red" />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
  },
  title: {
    fontSize: 32,
    fontWeight: "bold",
    marginBottom: 20,
  },
  inputContainer: {
    flexDirection: "row",
    marginBottom: 20,
  },
  input: {
    flex: 1,
    borderWidth: 1,
    borderColor: "#ddd",
    padding: 10,
    marginRight: 10,
    borderRadius: 5,
  },
  todoItem: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    padding: 15,
    borderBottomWidth: 1,
    borderBottomColor: "#eee",
  },
  todoText: {
    flex: 1,
    fontSize: 16,
  },
  completed: {
    textDecorationLine: "line-through",
    color: "#888",
  },
});

export default TodoList;
```

### 해답

<details>
<summary>해답 보기</summary>

```jsx
function TodoList() {
  const [todos, setTodos] = useState([
    { id: 1, text: "Buy milk", completed: false },
    { id: 2, text: "Clean room", completed: false },
  ]);
  const [input, setInput] = useState("");

  const addTodo = () => {
    if (input.trim() === "") return;

    const newTodo = {
      id: Date.now(),
      text: input,
      completed: false,
    };

    setTodos([...todos, newTodo]);
    setInput("");
  };

  const toggleTodo = (id) => {
    setTodos(todos.map((todo) => (todo.id === id ? { ...todo, completed: !todo.completed } : todo)));
  };

  const deleteTodo = (id) => {
    setTodos(todos.filter((todo) => todo.id !== id));
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Todo List</Text>

      <View style={styles.inputContainer}>
        <TextInput style={styles.input} value={input} onChangeText={setInput} placeholder="Enter todo" />
        <Button title="Add" onPress={addTodo} />
      </View>

      <FlatList
        data={todos}
        keyExtractor={(item) => item.id.toString()}
        renderItem={({ item }) => <TodoItem todo={item} onToggle={toggleTodo} onDelete={deleteTodo} />}
      />

      <Text style={styles.stats}>
        Total: {todos.length} | Completed: {todos.filter((t) => t.completed).length}
      </Text>
    </View>
  );
}
```

</details>

### 학습 포인트

- [ ] 배열 업데이트 시 불변성을 유지했는가?
- [ ] key prop을 고유한 id로 설정했는가?
- [ ] 조건부 스타일이 올바르게 적용되는가?

### 도전 과제

1. **필터링**: All / Active / Completed 탭 추가
2. **로컬 스토리지**: AsyncStorage로 저장/불러오기
3. **편집 기능**: 더블 클릭으로 텍스트 수정

---

## 프로젝트 3: 사용자 검색

### 목표

- useEffect로 API 호출
- Loading/Error 상태 관리
- Debouncing

### 요구사항

```jsx
import React, { useState, useEffect } from "react";
import { View, Text, TextInput, FlatList, ActivityIndicator, StyleSheet } from "react-native";

// Mock API
const searchUsers = async (query) => {
  await new Promise((resolve) => setTimeout(resolve, 500)); // 지연

  const users = [
    { id: 1, name: "Alice", email: "alice@example.com" },
    { id: 2, name: "Bob", email: "bob@example.com" },
    { id: 3, name: "Charlie", email: "charlie@example.com" },
  ];

  return users.filter((user) => user.name.toLowerCase().includes(query.toLowerCase()));
};

function UserSearch() {
  const [query, setQuery] = useState("");
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  // TODO: 구현하기
  // 1. query가 변경되면 500ms 후 검색 (debouncing)
  // 2. 로딩 상태 표시
  // 3. 에러 처리
  // 4. 이전 검색 취소 (cleanup)

  useEffect(() => {
    // 여기에 구현
  }, [query]);

  return (
    <View style={styles.container}>
      <TextInput style={styles.input} value={query} onChangeText={setQuery} placeholder="Search users..." />

      {loading && <ActivityIndicator size="large" />}

      {error && <Text style={styles.error}>{error}</Text>}

      <FlatList
        data={users}
        keyExtractor={(item) => item.id.toString()}
        renderItem={({ item }) => (
          <View style={styles.userItem}>
            <Text style={styles.name}>{item.name}</Text>
            <Text style={styles.email}>{item.email}</Text>
          </View>
        )}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
  },
  input: {
    borderWidth: 1,
    borderColor: "#ddd",
    padding: 10,
    borderRadius: 5,
    marginBottom: 20,
  },
  userItem: {
    padding: 15,
    borderBottomWidth: 1,
    borderBottomColor: "#eee",
  },
  name: {
    fontSize: 18,
    fontWeight: "bold",
  },
  email: {
    fontSize: 14,
    color: "#666",
  },
  error: {
    color: "red",
    marginBottom: 10,
  },
});

export default UserSearch;
```

### 해답

<details>
<summary>해답 보기</summary>

```jsx
function UserSearch() {
  const [query, setQuery] = useState("");
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  useEffect(() => {
    // 빈 검색어는 무시
    if (query.trim() === "") {
      setUsers([]);
      return;
    }

    // Debouncing: 500ms 후 검색
    const timeoutId = setTimeout(async () => {
      setLoading(true);
      setError(null);

      try {
        const results = await searchUsers(query);
        setUsers(results);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    }, 500);

    // Cleanup: 이전 타이머 취소
    return () => {
      clearTimeout(timeoutId);
    };
  }, [query]);

  return (
    <View style={styles.container}>
      <TextInput style={styles.input} value={query} onChangeText={setQuery} placeholder="Search users..." />

      {loading && <ActivityIndicator size="large" />}

      {error && <Text style={styles.error}>{error}</Text>}

      {!loading && users.length === 0 && query.trim() !== "" && <Text style={styles.noResults}>No users found</Text>}

      <FlatList
        data={users}
        keyExtractor={(item) => item.id.toString()}
        renderItem={({ item }) => (
          <View style={styles.userItem}>
            <Text style={styles.name}>{item.name}</Text>
            <Text style={styles.email}>{item.email}</Text>
          </View>
        )}
      />
    </View>
  );
}
```

</details>

### 학습 포인트

- [ ] useEffect의 cleanup 함수를 사용했는가?
- [ ] Loading/Error 상태를 올바르게 관리하는가?
- [ ] Debouncing이 작동하는가?
- [ ] 의존성 배열이 올바른가?

---

## 프로젝트 4: 온도 변환기

### 목표

- State 끌어올리기 (Lifting State Up)
- 양방향 데이터 흐름
- 계산된 값

### 요구사항

```jsx
import React, { useState } from "react";
import { View, Text, TextInput, StyleSheet } from "react-native";

function TemperatureConverter() {
  // TODO: State를 여기로 끌어올리기

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Temperature Converter</Text>

      <TemperatureInput
        scale="Celsius"
        // temperature={...}
        // onTemperatureChange={...}
      />

      <TemperatureInput
        scale="Fahrenheit"
        // temperature={...}
        // onTemperatureChange={...}
      />

      <Text style={styles.result}>{/* 끓는점 판정 메시지 */}</Text>
    </View>
  );
}

function TemperatureInput({ scale, temperature, onTemperatureChange }) {
  return (
    <View style={styles.inputContainer}>
      <Text style={styles.label}>{scale}:</Text>
      <TextInput
        style={styles.input}
        value={temperature}
        onChangeText={onTemperatureChange}
        keyboardType="numeric"
        placeholder="Enter temperature"
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
    justifyContent: "center",
  },
  title: {
    fontSize: 24,
    fontWeight: "bold",
    marginBottom: 30,
    textAlign: "center",
  },
  inputContainer: {
    marginBottom: 20,
  },
  label: {
    fontSize: 18,
    marginBottom: 5,
  },
  input: {
    borderWidth: 1,
    borderColor: "#ddd",
    padding: 10,
    borderRadius: 5,
    fontSize: 16,
  },
  result: {
    marginTop: 30,
    fontSize: 18,
    textAlign: "center",
    fontWeight: "bold",
  },
});

export default TemperatureConverter;
```

### 해답

<details>
<summary>해답 보기</summary>

```jsx
function toCelsius(fahrenheit) {
  return ((fahrenheit - 32) * 5) / 9;
}

function toFahrenheit(celsius) {
  return (celsius * 9) / 5 + 32;
}

function tryConvert(temperature, convert) {
  const input = parseFloat(temperature);
  if (Number.isNaN(input)) {
    return "";
  }
  const output = convert(input);
  const rounded = Math.round(output * 10) / 10;
  return rounded.toString();
}

function TemperatureConverter() {
  const [temperature, setTemperature] = useState("");
  const [scale, setScale] = useState("c");

  const handleCelsiusChange = (temp) => {
    setTemperature(temp);
    setScale("c");
  };

  const handleFahrenheitChange = (temp) => {
    setTemperature(temp);
    setScale("f");
  };

  const celsius = scale === "f" ? tryConvert(temperature, toCelsius) : temperature;
  const fahrenheit = scale === "c" ? tryConvert(temperature, toFahrenheit) : temperature;

  const boilingMessage = () => {
    const celsiusNum = parseFloat(celsius);
    if (Number.isNaN(celsiusNum)) {
      return "";
    }
    return celsiusNum >= 100 ? "🔥 The water would boil!" : "❄️ The water would not boil.";
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Temperature Converter</Text>

      <TemperatureInput scale="Celsius" temperature={celsius} onTemperatureChange={handleCelsiusChange} />

      <TemperatureInput scale="Fahrenheit" temperature={fahrenheit} onTemperatureChange={handleFahrenheitChange} />

      <Text style={styles.result}>{boilingMessage()}</Text>
    </View>
  );
}
```

</details>

### 학습 포인트

- [ ] State가 공통 부모로 올라갔는가?
- [ ] 양방향 변환이 올바르게 작동하는가?
- [ ] 계산된 값들이 정확한가?

---

## 코드베이스 분석 실습

### 실습 1: useState 호출 추적하기

1. React 소스코드 클론:

```bash
git clone https://github.com/facebook/react.git
cd react
```

2. VS Code에서 열기

3. 디버거 설정 (`.vscode/launch.json`):

```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "node",
      "request": "launch",
      "name": "Debug React",
      "skipFiles": ["<node_internals>/**"],
      "program": "${workspaceFolder}/packages/react/src/ReactHooks.js",
      "outFiles": ["${workspaceFolder}/**/*.js"]
    }
  ]
}
```

4. 브레이크포인트 설정:

   - `packages/react/src/ReactHooks.js` → `useState` 함수
   - `packages/react-reconciler/src/ReactFiberHooks.js` → `mountState`

5. 실행하고 call stack 확인

### 실습 2: Virtual DOM Diff 시각화

```jsx
import React, { useState } from "react";
import { View, Text, Button } from "react-native";

function VDOMVisualizer() {
  const [items, setItems] = useState(["A", "B", "C"]);

  const addItem = () => {
    setItems([...items, String.fromCharCode(65 + items.length)]);
  };

  const removeFirst = () => {
    setItems(items.slice(1));
  };

  const shuffleItems = () => {
    setItems([...items].sort(() => Math.random() - 0.5));
  };

  // React DevTools Profiler로 렌더링 확인
  console.log("Render:", items);

  return (
    <View>
      {items.map((item, index) => (
        <Text key={item}>
          {item} (index: {index})
        </Text>
      ))}

      <Button title="Add" onPress={addItem} />
      <Button title="Remove First" onPress={removeFirst} />
      <Button title="Shuffle" onPress={shuffleItems} />
    </View>
  );
}
```

**관찰 포인트**:

- React DevTools Profiler 열기
- 각 버튼 클릭 시 어떤 컴포넌트가 리렌더링되는지 확인
- key가 있을 때와 없을 때의 차이 비교

---

## 학습 점검

### Phase 1 완료 체크리스트

#### 이론

- [ ] React의 선언형 프로그래밍 철학 이해
- [ ] JSX가 React.createElement로 변환됨을 이해
- [ ] Props와 State의 차이 설명 가능
- [ ] Hooks의 규칙과 그 이유 이해
- [ ] Virtual DOM의 동작 원리 설명 가능

#### 코드베이스 분석

- [ ] useState의 실제 구현 위치 확인
- [ ] Hook이 연결 리스트로 저장됨을 확인
- [ ] Dispatcher 패턴 이해
- [ ] Fiber 노드 구조 파악

#### 실습

- [ ] 카운터 앱 완성
- [ ] Todo 리스트 완성
- [ ] 사용자 검색 완성
- [ ] 온도 변환기 완성

#### 심화

- [ ] React.memo 사용 가능
- [ ] useMemo, useCallback 차이 이해
- [ ] key prop의 중요성 이해
- [ ] Reconciliation 과정 설명 가능

---

## 다음 단계

Phase 1을 완료했다면:

1. **Phase 2**: Hooks 심화

   - Custom Hooks 만들기
   - useReducer로 복잡한 상태 관리
   - useContext로 전역 상태 공유

2. **Phase 3**: React Native

   - Native 컴포넌트 이해
   - Platform-specific 코드
   - Navigation

3. **Phase 4**: 상태 관리
   - Context API 심화
   - Redux, Zustand
   - React Query

**다음**: [07-학습-점검-질문.md](./07-학습-점검-질문.md)에서 학습 내용을 점검하세요!

축하합니다! Phase 1을 완료하셨습니다! 🎉
