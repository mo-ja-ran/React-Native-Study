# Phase 2 학습 점검 질문

---

## Section 1: useEffect 심화

### Q1. useEffect의 정리(cleanup) 함수는 언제 실행되는가?

### 답변 작성

```
[여기에 답변을 작성하세요]
1. interval prop가 변경될 때
2. 컴포넌트가 언마운트될 때
```

---

### Q2. useLayoutEffect와 useEffect의 차이점은?

### 답변 작성

```
[여기에 답변을 작성하세요]
useLayoutEffect는 화면이 그려지기 전, 동기적으로 호출됨. 그렇기에 무거운 작업은 지양해야 함.
useEffect는 화면이 그려진 후 비동기적으로 호출됨
```

---

### Q3. 다음 코드의 문제점은 무엇이며, 어떻게 해결할 수 있는가?

```jsx
function SearchBox({ apiEndpoint }) {
  const [results, setResults] = useState([]);
  const filters = { active: true, category: "tech" };

  useEffect(() => {
    fetch(apiEndpoint, { body: JSON.stringify(filters) })
      .then((res) => res.json())
      .then(setResults);
  }, [filters]); // filters가 의존성

  return <div>{results.length}개 결과</div>;
}
```

### 답변 작성

```
[여기에 답변을 작성하세요]
1. 매 렌더링마다 새 객체가 생성되어서, 의존성인 filters가 매번 달라짐
2. clenup 함수가 없어서 api 요청을 취소할 수 없음
```

---

### Q4. Race Condition이란 무엇이며, useEffect에서 어떻게 방지하는가?

### 답변 작성

```
[여기에 답변을 작성하세요]
Race Condition은 둘 이상의 비동기 작업이 예상치 못한 순서로 실행되면서 개발자의 의도와는 다른 상황을 의미함.
useEffect에서 Cleanup 함수를 통한 flag를 세워 최신 요청만 반영되도록 하거나, AbortController를 사용하여 요청을 취소하여 방지한다.
```

---

## Section 2: 성능 최적화

### Q5. useRef와 useState의 가장 큰 차이는 무엇인가?

### 답변 작성

```
[여기에 답변을 작성하세요]
useState는 변경 시 리렌더링을 진행하지만, useRef는 리렌더링이 없음
```

---

### Q6. useMemo와 useCallback은 언제 사용해야 하는가?

### 답변 작성

```
[여기에 답변을 작성하세요]
둘 다 최적화가 필요한 경우에 사용하는 것을 전제로 한다.
useMemo는 객체의 메모이제이션, useCallback은 함수의 메모이제이션이 필요할 때 사용한다.
```

---

### Q7. 다음 코드에서 ChildComponent는 몇 번 리렌더링되는가?

```jsx
function ParentComponent() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState("");

  const user = { name: "John", age: 30 };
  const handleClick = () => console.log("Clicked");

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>증가</button>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <ChildComponent user={user} onClick={handleClick} />
    </div>
  );
}

const ChildComponent = React.memo(({ user, onClick }) => {
  console.log("ChildComponent 렌더링");
  return <div>{user.name}</div>;
});
```

### 답변 작성

```
[여기에 답변을 작성하세요]
질문이 좀 잘못된 거 같긴 한데,
ChildComponent는 React.memo로 감싸긴 했지만, ParentComponent에서 내려주는 user와 handleClick이 렌더링할 때마다 새로 생성되기에 메모이제이션을 안한 것과 같은 효과.
클릭을 하거나 input을 입력할 때마다 ChildComponent는 리렌더링 된다.



```

---

## Section 3: Custom Hooks

### Q8. Custom Hook을 만들 때 주의할 점은 무엇인가?

### 답변 작성

```
[여기에 답변을 작성하세요]






```

---

### Q9. 다음 Custom Hook의 문제점과 개선 방법은?

```jsx
function useFetch(url) {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch(url)
      .then((res) => res.json())
      .then(setData);
  }, [url]);

  return data;
}
```

### 답변 작성

```
[여기에 답변을 작성하세요]








```

---

## Section 4: 내부 구조

### Q10. 의존성 배열에 객체를 넣으면 왜 문제가 되는가?

### 답변 작성

```
[여기에 답변을 작성하세요]






```

---

### Q11. useEffect 안에서 async/await를 직접 사용할 수 없는 이유는?

### 답변 작성

```
[여기에 답변을 작성하세요]






```

---

## Section 5: 실무 시나리오

### Q12. 1000개 아이템 리스트를 최적화하는 방법은?

### 답변 작성

```
[여기에 답변을 작성하세요]








```

---

### Q13. API 호출이 여러 번 발생하는 것을 방지하는 방법은?

### 답변 작성

```
[여기에 답변을 작성하세요]








```

---

## Section 6: 종합 문제

### Q14. 다음 코드를 최적화하고, 문제점을 설명하시오.

```jsx
function ProductList({ products, category }) {
  const [sortBy, setSortBy] = useState("name");

  const filteredProducts = products.filter((p) => p.category === category);
  const sortedProducts = filteredProducts.sort((a, b) => (a[sortBy] > b[sortBy] ? 1 : -1));

  const handleSort = (field) => {
    setSortBy(field);
  };

  return (
    <div>
      <button onClick={() => handleSort("name")}>이름순</button>
      <button onClick={() => handleSort("price")}>가격순</button>

      {sortedProducts.map((p) => (
        <ProductCard key={p.id} product={p} onAddToCart={() => addToCart(p)} />
      ))}
    </div>
  );
}
```

### 답변 작성

```
[여기에 답변을 작성하세요]










```

---

### 다음 단계

Phase 2를 완료했다면, 이제 React Native와 상태관리 라이브러리를 학습할 준비가 되었습니다!

**다음**: Phase 3 - React Native 기초
