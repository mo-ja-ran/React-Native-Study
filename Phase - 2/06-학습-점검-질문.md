# Phase 2 학습 점검 질문

---

## Section 1: useEffect 심화

### Q1. useEffect의 정리(cleanup) 함수는 언제 실행되는가?

### 답변 작성

```
[여기에 답변을 작성하세요]




```

---

### Q2. useLayoutEffect와 useEffect의 차이점은?

### 답변 작성

```
[여기에 답변을 작성하세요]




```

---

### Q3. 다음 코드의 문제점은 무엇이며, 어떻게 해결할 수 있는가?

```jsx
function SearchBox({ apiEndpoint }) {
  const [results, setResults] = useState([]);
  const filters = { active: true, category: "tech" };

  useEffect(() => {
    fetch(apiEndpoint, { body: JSON.stringify(filters) })
      .then((res) => res.json())
      .then(setResults);
  }, [filters]); // filters가 의존성

  return <div>{results.length}개 결과</div>;
}
```

### 답변 작성

```
[여기에 답변을 작성하세요]






```

---

### Q4. Race Condition이란 무엇이며, useEffect에서 어떻게 방지하는가?

### 답변 작성

```
[여기에 답변을 작성하세요]






```

---

## Section 2: 성능 최적화

### Q5. useRef와 useState의 가장 큰 차이는 무엇인가?

### 답변 작성

```
[여기에 답변을 작성하세요]




```

---

### Q6. useMemo와 useCallback은 언제 사용해야 하는가?

### 답변 작성

```
[여기에 답변을 작성하세요]






```

---

### Q7. 다음 코드에서 ChildComponent는 몇 번 리렌더링되는가?

```jsx
function ParentComponent() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState("");

  const user = { name: "John", age: 30 };
  const handleClick = () => console.log("Clicked");

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>증가</button>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <ChildComponent user={user} onClick={handleClick} />
    </div>
  );
}

const ChildComponent = React.memo(({ user, onClick }) => {
  console.log("ChildComponent 렌더링");
  return <div>{user.name}</div>;
});
```

### 답변 작성

```
[여기에 답변을 작성하세요]






```

---

## Section 3: Custom Hooks

### Q8. Custom Hook을 만들 때 주의할 점은 무엇인가?

### 답변 작성

```
[여기에 답변을 작성하세요]






```

---

### Q9. 다음 Custom Hook의 문제점과 개선 방법은?

```jsx
function useFetch(url) {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch(url)
      .then((res) => res.json())
      .then(setData);
  }, [url]);

  return data;
}
```

### 답변 작성

```
[여기에 답변을 작성하세요]








```

---

## Section 4: 내부 구조

### Q10. 의존성 배열에 객체를 넣으면 왜 문제가 되는가?

### 답변 작성

```
[여기에 답변을 작성하세요]






```

---

### Q11. useEffect 안에서 async/await를 직접 사용할 수 없는 이유는?

### 답변 작성

```
[여기에 답변을 작성하세요]






```

---

## Section 5: 실무 시나리오

### Q12. 1000개 아이템 리스트를 최적화하는 방법은?

### 답변 작성

```
[여기에 답변을 작성하세요]








```

---

### Q13. API 호출이 여러 번 발생하는 것을 방지하는 방법은?

### 답변 작성

```
[여기에 답변을 작성하세요]








```

---

## Section 6: 종합 문제

### Q14. 다음 코드를 최적화하고, 문제점을 설명하시오.

```jsx
function ProductList({ products, category }) {
  const [sortBy, setSortBy] = useState("name");

  const filteredProducts = products.filter((p) => p.category === category);
  const sortedProducts = filteredProducts.sort((a, b) => (a[sortBy] > b[sortBy] ? 1 : -1));

  const handleSort = (field) => {
    setSortBy(field);
  };

  return (
    <div>
      <button onClick={() => handleSort("name")}>이름순</button>
      <button onClick={() => handleSort("price")}>가격순</button>

      {sortedProducts.map((p) => (
        <ProductCard key={p.id} product={p} onAddToCart={() => addToCart(p)} />
      ))}
    </div>
  );
}
```

### 답변 작성

```
[여기에 답변을 작성하세요]










```

---

### 다음 단계

Phase 2를 완료했다면, 이제 React Native와 상태관리 라이브러리를 학습할 준비가 되었습니다!

**다음**: Phase 3 - React Native 기초
