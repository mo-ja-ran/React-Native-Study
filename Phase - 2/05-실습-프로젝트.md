# Phase 2 실습 프로젝트

## 📌 학습 목표

Phase 2에서 배운 고급 Hooks와 최적화 기법을 실제 프로젝트에 적용하여 실무 감각을 키웁니다.

---

## 프로젝트 1: 실시간 검색 기능

### 목표

- useDebounce Custom Hook 구현
- useFetch Custom Hook 구현
- API 호출 최적화

### 요구사항

1. 입력 필드에 검색어 입력
2. 타이핑 중에는 API 호출 안 함 (debounce)
3. 타이핑 멈춘 후 500ms 뒤 자동 검색
4. 로딩 상태 표시
5. 검색 결과 리스트 렌더링

### 구현

```jsx
// hooks/useDebounce.js
import { useState, useEffect } from "react";

function useDebounce(value, delay = 500) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => clearTimeout(timer);
  }, [value, delay]);

  return debouncedValue;
}

export default useDebounce;
```

```jsx
// hooks/useFetch.js
import { useState, useEffect, useCallback } from "react";

function useFetch(url, options = {}) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const fetchData = useCallback(async () => {
    if (!url) {
      setData(null);
      return;
    }

    try {
      setLoading(true);
      setError(null);

      const response = await fetch(url, options);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const json = await response.json();
      setData(json);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, [url]);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  return { data, loading, error, refetch: fetchData };
}

export default useFetch;
```

```jsx
// components/SearchBox.jsx
import { useState } from "react";
import useDebounce from "../hooks/useDebounce";
import useFetch from "../hooks/useFetch";

function SearchBox() {
  const [searchTerm, setSearchTerm] = useState("");
  const debouncedSearchTerm = useDebounce(searchTerm, 500);

  const url = debouncedSearchTerm ? `https://api.github.com/search/users?q=${debouncedSearchTerm}` : null;

  const { data, loading, error } = useFetch(url);

  return (
    <div className="search-box">
      <input
        type="text"
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        placeholder="GitHub 사용자 검색..."
        className="search-input"
      />

      {loading && <div className="loading">검색 중...</div>}
      {error && <div className="error">에러: {error}</div>}

      {data && (
        <ul className="search-results">
          {data.items.map((user) => (
            <li key={user.id} className="search-result-item">
              <img src={user.avatar_url} alt={user.login} width={50} />
              <div>
                <h3>{user.login}</h3>
                <a href={user.html_url} target="_blank" rel="noopener noreferrer">
                  프로필 보기
                </a>
              </div>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}

export default SearchBox;
```

### 체크리스트

- [ ] useDebounce Hook 구현
- [ ] useFetch Hook 구현
- [ ] 검색어 입력 시 debounce 동작 확인
- [ ] 로딩 상태 표시
- [ ] 에러 처리
- [ ] 검색 결과 렌더링

---

## 프로젝트 2: 무한 스크롤 리스트

### 목표

- useIntersectionObserver Custom Hook 구현
- 스크롤 기반 페이지네이션
- 성능 최적화 (React.memo)

### 요구사항

1. 초기 데이터 20개 로드
2. 스크롤 하단 도달 시 자동으로 다음 페이지 로드
3. 로딩 인디케이터 표시
4. 모든 데이터 로드 완료 시 메시지 표시

### 구현

```jsx
// hooks/useIntersectionObserver.js
import { useEffect, useState } from "react";

function useIntersectionObserver(ref, options = {}) {
  const [isIntersecting, setIntersecting] = useState(false);
  const [hasIntersected, setHasIntersected] = useState(false);

  useEffect(() => {
    if (!ref.current) return;

    const observer = new IntersectionObserver(([entry]) => {
      setIntersecting(entry.isIntersecting);

      if (entry.isIntersecting && !hasIntersected) {
        setHasIntersected(true);
      }
    }, options);

    observer.observe(ref.current);

    return () => {
      if (ref.current) {
        observer.unobserve(ref.current);
      }
    };
  }, [ref, options]);

  return { isIntersecting, hasIntersected };
}

export default useIntersectionObserver;
```

```jsx
// hooks/useInfiniteScroll.js
import { useState, useEffect, useCallback } from "react";

function useInfiniteScroll(fetchFunction) {
  const [items, setItems] = useState([]);
  const [page, setPage] = useState(1);
  const [loading, setLoading] = useState(false);
  const [hasMore, setHasMore] = useState(true);
  const [error, setError] = useState(null);

  const loadMore = useCallback(async () => {
    if (loading || !hasMore) return;

    try {
      setLoading(true);
      setError(null);

      const newItems = await fetchFunction(page);

      if (newItems.length === 0) {
        setHasMore(false);
      } else {
        setItems((prev) => [...prev, ...newItems]);
        setPage((prev) => prev + 1);
      }
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, [page, loading, hasMore, fetchFunction]);

  // 초기 로드
  useEffect(() => {
    loadMore();
  }, []);

  return { items, loading, hasMore, error, loadMore };
}

export default useInfiniteScroll;
```

```jsx
// components/InfiniteList.jsx
import { useRef, useEffect, memo } from "react";
import useInfiniteScroll from "../hooks/useInfiniteScroll";
import useIntersectionObserver from "../hooks/useIntersectionObserver";

// 개별 아이템 컴포넌트 (최적화)
const ListItem = memo(({ item }) => {
  console.log("Rendering item:", item.id);

  return (
    <div className="list-item">
      <h3>{item.title}</h3>
      <p>{item.description}</p>
    </div>
  );
});

function InfiniteList() {
  const loadMoreRef = useRef(null);
  const { isIntersecting } = useIntersectionObserver(loadMoreRef, {
    threshold: 0.5,
  });

  // API 호출 함수
  const fetchItems = async (page) => {
    const response = await fetch(`https://jsonplaceholder.typicode.com/posts?_page=${page}&_limit=20`);
    return response.json();
  };

  const { items, loading, hasMore, error, loadMore } = useInfiniteScroll(fetchItems);

  // 하단 도달 시 자동 로드
  useEffect(() => {
    if (isIntersecting && !loading && hasMore) {
      loadMore();
    }
  }, [isIntersecting, loading, hasMore, loadMore]);

  return (
    <div className="infinite-list">
      <h1>무한 스크롤 리스트</h1>

      <div className="list-container">
        {items.map((item) => (
          <ListItem key={item.id} item={item} />
        ))}
      </div>

      {/* 로딩 인디케이터 */}
      {loading && (
        <div className="loading-indicator">
          <p>로딩 중...</p>
        </div>
      )}

      {/* 하단 감지 요소 */}
      {hasMore && !loading && <div ref={loadMoreRef} className="load-more-trigger" />}

      {/* 모든 데이터 로드 완료 */}
      {!hasMore && (
        <div className="end-message">
          <p>모든 항목을 불러왔습니다.</p>
        </div>
      )}

      {/* 에러 */}
      {error && (
        <div className="error">
          <p>에러: {error}</p>
          <button onClick={loadMore}>재시도</button>
        </div>
      )}
    </div>
  );
}

export default InfiniteList;
```

### 체크리스트

- [ ] useIntersectionObserver Hook 구현
- [ ] useInfiniteScroll Hook 구현
- [ ] 스크롤 하단 도달 시 자동 로드
- [ ] ListItem을 React.memo로 최적화
- [ ] 로딩/에러 상태 처리
- [ ] 모든 데이터 로드 완료 시 메시지

---

## 프로젝트 3: 다크모드 토글

### 목표

- useLocalStorage Custom Hook 활용
- Context API와 Custom Hook 조합
- 테마 전환 최적화

### 요구사항

1. 라이트/다크 모드 토글
2. 선택한 테마를 localStorage에 저장
3. 페이지 새로고침 시에도 테마 유지
4. 전역 상태 관리 (Context)

### 구현

```jsx
// hooks/useLocalStorage.js
import { useState, useCallback } from "react";

function useLocalStorage(key, initialValue) {
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(error);
      return initialValue;
    }
  });

  const setValue = useCallback(
    (value) => {
      try {
        const valueToStore = value instanceof Function ? value(storedValue) : value;
        setStoredValue(valueToStore);
        window.localStorage.setItem(key, JSON.stringify(valueToStore));
      } catch (error) {
        console.error(error);
      }
    },
    [key, storedValue]
  );

  return [storedValue, setValue];
}

export default useLocalStorage;
```

```jsx
// context/ThemeContext.jsx
import { createContext, useContext, useMemo } from "react";
import useLocalStorage from "../hooks/useLocalStorage";

const ThemeContext = createContext();

export function ThemeProvider({ children }) {
  const [theme, setTheme] = useLocalStorage("theme", "light");

  const value = useMemo(
    () => ({
      theme,
      toggleTheme: () => setTheme((prev) => (prev === "light" ? "dark" : "light")),
      setTheme,
    }),
    [theme, setTheme]
  );

  return (
    <ThemeContext.Provider value={value}>
      <div className={`app theme-${theme}`}>{children}</div>
    </ThemeContext.Provider>
  );
}

export function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error("useTheme must be used within ThemeProvider");
  }
  return context;
}
```

```jsx
// components/ThemeToggle.jsx
import { useTheme } from "../context/ThemeContext";

function ThemeToggle() {
  const { theme, toggleTheme } = useTheme();

  return (
    <button onClick={toggleTheme} className="theme-toggle">
      {theme === "light" ? "🌙" : "☀️"}
      {theme === "light" ? "다크 모드" : "라이트 모드"}
    </button>
  );
}

export default ThemeToggle;
```

```jsx
// App.jsx
import { ThemeProvider } from "./context/ThemeContext";
import ThemeToggle from "./components/ThemeToggle";

function App() {
  return (
    <ThemeProvider>
      <div className="app">
        <header>
          <h1>다크모드 앱</h1>
          <ThemeToggle />
        </header>

        <main>
          <p>테마를 전환해보세요!</p>
        </main>
      </div>
    </ThemeProvider>
  );
}

export default App;
```

```css
/* styles.css */
.theme-light {
  --bg-color: #ffffff;
  --text-color: #000000;
  --border-color: #dddddd;
}

.theme-dark {
  --bg-color: #1a1a1a;
  --text-color: #ffffff;
  --border-color: #444444;
}

.app {
  background-color: var(--bg-color);
  color: var(--text-color);
  min-height: 100vh;
  transition: background-color 0.3s, color 0.3s;
}

.theme-toggle {
  padding: 10px 20px;
  border: 1px solid var(--border-color);
  background-color: var(--bg-color);
  color: var(--text-color);
  cursor: pointer;
  border-radius: 5px;
  transition: all 0.3s;
}

.theme-toggle:hover {
  transform: scale(1.05);
}
```

### 체크리스트

- [ ] useLocalStorage Hook 활용
- [ ] ThemeContext 구성
- [ ] useTheme Custom Hook 구현
- [ ] 테마 전환 기능
- [ ] localStorage 저장/불러오기
- [ ] CSS 변수로 테마 적용

---

## 프로젝트 4: 성능 최적화된 대용량 리스트

### 목표

- React.memo, useMemo, useCallback 활용
- 실제 성능 측정
- 최적화 전후 비교

### 요구사항

1. 1000개 이상의 아이템 리스트
2. 필터링 기능
3. 정렬 기능
4. 개별 아이템 편집 가능
5. 불필요한 리렌더링 최소화

### 구현

```jsx
// components/OptimizedList.jsx
import { useState, useMemo, useCallback, memo } from "react";

// 아이템 컴포넌트 (최적화)
const ListItem = memo(({ item, onEdit, onDelete }) => {
  console.log("Rendering item:", item.id);

  return (
    <div className="list-item">
      <span>{item.name}</span>
      <span>${item.price}</span>
      <button onClick={() => onEdit(item.id)}>편집</button>
      <button onClick={() => onDelete(item.id)}>삭제</button>
    </div>
  );
});

function OptimizedList() {
  const [items, setItems] = useState(() => {
    // 1000개 초기 데이터 생성
    return Array.from({ length: 1000 }, (_, i) => ({
      id: i + 1,
      name: `상품 ${i + 1}`,
      price: Math.floor(Math.random() * 1000),
      category: ["전자", "의류", "식품"][Math.floor(Math.random() * 3)],
    }));
  });

  const [filter, setFilter] = useState("");
  const [sortBy, setSortBy] = useState("name");
  const [category, setCategory] = useState("all");

  // 필터링 + 정렬 (메모이제이션)
  const processedItems = useMemo(() => {
    console.log("필터링+정렬 실행");

    let result = items;

    // 카테고리 필터
    if (category !== "all") {
      result = result.filter((item) => item.category === category);
    }

    // 검색 필터
    if (filter) {
      result = result.filter((item) => item.name.toLowerCase().includes(filter.toLowerCase()));
    }

    // 정렬
    result = [...result].sort((a, b) => {
      if (sortBy === "name") {
        return a.name.localeCompare(b.name);
      } else if (sortBy === "price") {
        return a.price - b.price;
      }
      return 0;
    });

    return result;
  }, [items, filter, sortBy, category]);

  // 핸들러 메모이제이션
  const handleEdit = useCallback((id) => {
    const newName = prompt("새 이름:");
    if (newName) {
      setItems((prev) => prev.map((item) => (item.id === id ? { ...item, name: newName } : item)));
    }
  }, []);

  const handleDelete = useCallback((id) => {
    if (confirm("삭제하시겠습니까?")) {
      setItems((prev) => prev.filter((item) => item.id !== id));
    }
  }, []);

  return (
    <div className="optimized-list">
      <div className="controls">
        <input type="text" value={filter} onChange={(e) => setFilter(e.target.value)} placeholder="검색..." />

        <select value={category} onChange={(e) => setCategory(e.target.value)}>
          <option value="all">전체</option>
          <option value="전자">전자</option>
          <option value="의류">의류</option>
          <option value="식품">식품</option>
        </select>

        <select value={sortBy} onChange={(e) => setSortBy(e.target.value)}>
          <option value="name">이름순</option>
          <option value="price">가격순</option>
        </select>
      </div>

      <p>총 {processedItems.length}개 항목</p>

      <div className="list-container">
        {processedItems.map((item) => (
          <ListItem key={item.id} item={item} onEdit={handleEdit} onDelete={handleDelete} />
        ))}
      </div>
    </div>
  );
}

export default OptimizedList;
```

### 성능 측정

```jsx
// React DevTools Profiler 사용
import { Profiler } from "react";

function App() {
  const onRenderCallback = (id, phase, actualDuration, baseDuration, startTime, commitTime) => {
    console.log(`${id} (${phase}):`, {
      actualDuration,
      baseDuration,
    });
  };

  return (
    <Profiler id="OptimizedList" onRender={onRenderCallback}>
      <OptimizedList />
    </Profiler>
  );
}
```

### 체크리스트

- [ ] ListItem을 React.memo로 감싸기
- [ ] processedItems를 useMemo로 메모이제이션
- [ ] 핸들러를 useCallback으로 메모이제이션
- [ ] React DevTools Profiler로 성능 측정
- [ ] 최적화 전후 렌더링 시간 비교

---

## 프로젝트 5: API 캐싱 시스템

### 목표

- useMemo를 활용한 응답 캐싱
- 중복 요청 방지
- 캐시 무효화 전략

### 구현

```jsx
// hooks/useCachedFetch.js
import { useState, useEffect, useCallback, useRef } from "react";

const cache = new Map();

function useCachedFetch(url, options = {}) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const abortControllerRef = useRef(null);

  const fetchData = useCallback(
    async (forceRefresh = false) => {
      if (!url) return;

      // 캐시 확인
      if (!forceRefresh && cache.has(url)) {
        console.log("Cache hit:", url);
        setData(cache.get(url));
        return;
      }

      try {
        // 이전 요청 취소
        if (abortControllerRef.current) {
          abortControllerRef.current.abort();
        }

        abortControllerRef.current = new AbortController();

        setLoading(true);
        setError(null);

        const response = await fetch(url, {
          ...options,
          signal: abortControllerRef.current.signal,
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const json = await response.json();

        // 캐시에 저장
        cache.set(url, json);
        setData(json);
      } catch (err) {
        if (err.name !== "AbortError") {
          setError(err.message);
        }
      } finally {
        setLoading(false);
      }
    },
    [url, options]
  );

  const invalidateCache = useCallback(() => {
    cache.delete(url);
    fetchData(true);
  }, [url, fetchData]);

  useEffect(() => {
    fetchData();

    return () => {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, [fetchData]);

  return {
    data,
    loading,
    error,
    refetch: () => fetchData(true),
    invalidateCache,
  };
}

export default useCachedFetch;
```

### 체크리스트

- [ ] 캐시 Map 구현
- [ ] 캐시 히트/미스 로직
- [ ] 강제 새로고침 기능
- [ ] 중복 요청 방지 (AbortController)
- [ ] 캐시 무효화 기능

---

## 정리

### 완료해야 할 프로젝트

- [ ] 프로젝트 1: 실시간 검색
- [ ] 프로젝트 2: 무한 스크롤
- [ ] 프로젝트 3: 다크모드 토글
- [ ] 프로젝트 4: 성능 최적화 리스트
- [ ] 프로젝트 5: API 캐싱

### 배운 내용

1. Custom Hooks 실전 활용
2. 성능 최적화 기법 적용
3. 실제 문제 해결 경험
4. 코드 재사용성 향상

**다음**: [06-학습-점검-질문.md](./06-학습-점검-질문.md)
